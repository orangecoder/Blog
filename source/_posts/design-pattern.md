title: 设计模式总结
date: 2016-06-04 20:35:02
tags:
---

总体来说设计模式分为三大类：

* 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

* 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

* 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

# `创建型模式`

## 1. 工厂方法模式（Factory Method)

* 普通工厂模式
建立一个工厂类，对实现了同一接口的一些类进行实例的创建
![](/image/design-pattern-1.png)

* 多个工厂方法模式
对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象

* 静态工厂方法模式
将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可

总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。

## 2. 抽象工厂模式（Abstract Factory）

工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑， 有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码
![](/image/design-pattern-2.jpg)
其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！

## 3. 单例模式（Singleton）
在 Java 应用中，单例对象能保证在一个 JVM 中，该对象只有一个实例存在。这样的模式有几个好处：
1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。
2、省去了 new 操作符，降低了系统内存的使用频率，减轻 GC 压力。
3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程

* 懒汉
```JAVA
public class Singleton {  
	private static Singleton instance;  
	private Singleton (){}
	public static synchronized Singleton getInstance() {  
		if (instance == null) {  
	  		instance = new Singleton();  
		}  
		return instance;  
	}  
}  
```
这种写法能够在多线程中很好的工作，而且看起来它也具备很好的 lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步

* 饿汉
```JAVA
public class Singleton {  
	private static Singleton instance = new Singleton();  
	private Singleton (){}
	public static Singleton getInstance() {  
		return instance;  
	}  
}  
```
这种方式基于 classloder 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。

* 静态内部类
```JAVA
public class Singleton {  
	private static class SingletonHolder {  
		private static final Singleton INSTANCE = new Singleton();  
	}  
	private Singleton (){}
	public static final Singleton getInstance() {  
		return SingletonHolder.INSTANCE;  
	}  
}  
```
这种方式同样利用了 classloder 的机制来保证初始化 instance 时只有一个线程，它跟饿汉不同的是（很细微的差别）：饿汉是只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有显示通过调用 getInstance 方法时，才会显示装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，我想让他延迟加载，另外一方面，我不希望在 Singleton 类加载时就实例化，因为我不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比饿汉就显得很合理。

* 枚举
```JAVA
public enum Singleton {  
	INSTANCE;  
	public void whateverMethod() {  
	}  
}  
```
这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊

* 双重校验锁
```JAVA
public class Singleton {  
	private volatile static Singleton singleton;  
	private Singleton (){}   
	public static Singleton getSingleton() {  
		if (singleton == null) {  
			synchronized (Singleton.class) {  
				if (singleton == null) {  
					singleton = new Singleton();  
				}  
			}  
		}  
		return singleton;  
	}  
}  
```
## 4. 建造者模式（Builder）
工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性。建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工厂模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。

## 5. 原型模式（Prototype）
该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。
* 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。
* 深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。
要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象

# `结构型模式`

## 6. 适配器模式 (Adapter)
适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式

* 类的适配器模式
核心思想就是：有一个 Source 类，拥有一个方法，待适配，目标接口是 Targetable，通过 Adapter 类，将 Source 的功能扩展到 Targetable 里，这样 Targetable 接口的实现类就具有了 Source 类的功能
![](/image/design-pattern-6-1.jpg)

* 对象的适配器模式
基本思路和类的适配器模式相同，只是将 Adapter 类作修改，这次不继承 Source 类，而是持有 Source 类的实例，以达到解决兼容性的问题
![](/image/design-pattern-6-2.jpg)

* 接口的适配器模式
接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行
![](/image/design-pattern-6-3.jpg)

类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。
对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个 Wrapper 类，持有原类的一个实例，在 Wrapper 类的方法中，调用实例的方法就行。
接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类 Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。

## 7. 装饰模式（Decorator）
装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例
![](/image/design-pattern-7.jpg)
Source 类是被装饰类，Decorator 类是一个装饰类，可以为 Source 类动态的添加一些功能
装饰器模式的应用场景：
1、需要扩展一个类的功能。
2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）
缺点：产生过多相似的对象，不易排错！

##  8. 代理模式（Proxy）
代理模式就是多一个代理类出来，替原对象进行一些操作
![](/image/design-pattern-8.jpg)
代理模式的应用场景：
如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
使用代理模式，可以将功能划分的更加清晰，有助于后期维护！

## 9. 外观模式（Facade）
外观模式是为了解决类与类之家的依赖关系的，像 spring 一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个 Facade 类中，降低了类类之间的耦合度，该模式中没有涉及到接口
![](/image/design-pattern-9.jpg)

## 10. 桥接模式（Bridge）
桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的 JDBC 桥 DriverManager 一样，JDBC 进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是 JDBC 提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了
![](/image/design-pattern-10.jpg)

## 11. 组合模式（Composite）
组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便
![](/image/design-pattern-11.jpg)
使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。

## 12. 享元模式（Flyweight）
享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用
![](/image/design-pattern-12.jpg)

# `行为型模式`

![](/image/design-pattern-3a.jpg)

## 13. 策略模式（strategy）
策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数
![](/image/design-pattern-13.jpg)
策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可

## 14. 模板方法模式（Template Method）
模板方法模式就是指：一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用
![](/image/design-pattern-14.jpg)

## 15. 观察者模式（Observer）
当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！ 对象之间是一种一对多的关系。
![](/image/design-pattern-15.jpg)
MySubject类就是我们的主对象，Observer1 和 Observer2 是依赖于 MySubject 的对象，当 MySubject 变化时，Observer1 和Observer2 必然变化。AbstractSubject 类中定义着需要监控的对象列表，可以对其进 行修改：增加或删除被监控对象，且当 MySubject 变化时，负责通知在列表内存在的对象

## 16. 迭代器模式（Iterator）
迭代器模式就是顺序访问聚集中的对象，这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问
![](/image/design-pattern-16.jpg)

## 17. 责任链模式（Chain of Responsibility）
有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发 出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。
![](/image/design-pattern-17.jpg)

## 18. 命令模式（Command）
命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里， 士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。
![](/image/design-pattern-18.jpg)
Invoker 是调用者（司令员），Receiver 是被调用者（士兵），MyCommand 是命令，实现了 Command 接口，持有接收对象。命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开。

## 19. 备忘录模式（Memento）
主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象
![](/image/design-pattern-19.jpg)
Original 类是原始类，里面有需要保存的属性 value 及创建一个备忘录类，用来保存 value 值。Memento 类是备忘录类，Storage 类是存储备忘录的类，持有 Memento 类的实例

## 20. 状态模式（State）
当对象的状态改变时，同时改变其行为。
![](/image/design-pattern-20.jpg)
状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。

## 21. 访问者模式（Visitor）
访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果
![](/image/design-pattern-21.jpg)
适用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情：1、新功能会不会与现有功能出现兼容性问题？2、以后会不会再需要添 加？3、如果类不允许修改代码怎么办？面对这些问题，最好的解决方法就是使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦，

## 22. 中介者模式（Mediator）
中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和 Mediator 类的关系，具体类类之间的关系及调度交给 Mediator 就行，这有点像 spring 容器的作用
![](/image/design-pattern-22.jpg)
User 类统一接口，User1 和 User2 分别是不同的对象，二者之间有关联，如果不采用中介者模式，则需要二者相互持有引用，这样二者的耦合度很高，为了解耦，引入了 Mediator 类，提供统一接口，MyMediator 为其实现类，里面持有 User1 和 User2 的实例，用来实现对 User1 和 User2 的控制。这样 User1 和 User2 两个对象相互独立，他们只需要保持好和 Mediator 之间的关系就行，剩下的全由 MyMediator 类来维护！

## 23. 解释器模式（Interpreter）
![](/image/design-pattern-23.jpg)


[参考](http://www.jfox.info/java-23-zhong-she-ji-mo-shi-ji-ju-ti-li-zi)